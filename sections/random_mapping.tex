\chapter{Картирование методом стохастического градиента}
\label{random_mapping}

Используя прямую модель Труна, мы предлагаем метод картирования, который использует преимущества прямой модели, при этом допускает реализацию, работающую в режиме реального времени. Как и раньше, через $m$ будем обозначать карту проходимости. Через $S$ - множество сонаров $s$. Через $o(m_i)$ будем обозначать занятость клетки $m_i$: $o(m_i) = 0$ - клетка проходима, $o(m_i) = 1$ - клетка непроходима. 

Вначале введем функционал, состоящий из прямой модели сенсора и априорных представлениях об окружении. Затем случайным градиентным спуском будем максимизировать величину этого функционала.

\section{Функционал правдоподобия карты проходимости}

Введем следующий функционал от $m$ при заданных наблюдениях $S$:

\begin{equation}\label{random:1}
  \Phi(m,S) = \phi_{sonars}(m,S) + \phi_{occupancy}(m) + \phi_{borders}(m),
\end{equation} 

Рассмотрим составляющие функционала \eqref{random:1}

\begin{enumerate}
  \item $\phi_{sonars}$ - распределение наблюдений сонаров $z_s$ при заданной карте проходимости $m$.   
  \begin{equation}\label{random:2}
    \phi_{sonars}(m,S) = p(z_1,...,z_S|m) = \prod_{s \in S}{p(z_s|m)}
  \end{equation}

  Эта часть функционала \eqref{random:1} показывает на сколько хорошо карта $m$ объясняет показание сонаров $s \in S$. В работе в качестве модели сонара $p(z_s|m)$ используется прямая модель Труна. Вместо \eqref{random:2} в окончательной формуле используется логарифм правдоподобия:

  \begin{equation}\label{random:2.1}
    \phi_{sonars}(m,S) = \log p(z_1,...,z_S|m) = \sum_{s \in S}{\log p(z_s|m)}
  \end{equation}

  \item $\phi_{occupancy}(m)$ отвечает за априорные знания о проходимости карты

  \begin{equation}\label{random:3}
    \phi_{occupancy}(m) = \sum_{m_i}{w_{o}o(m_i)}
  \end{equation}

  В зависимости от значения весового коэффициента $w_o$ можно регулировать наше первоначальное представление о карте, без учета наблюдений сонаров. Например, при $w_o < 0$ и $\phi_{sonars}(m,S) = const$ пустая карта будет максимизировать $\Phi(m,S)$.

  \item $\phi_{borders}(m)$ является суммой штрафов для каждой клетки, пропорциональный квадрату числа границ между проходимой и непроходимой областью этой ячейки

  \begin{equation}\label{random:4}
    \phi_{borders}(m) = \sum_{m_i}{w_{b}n^2(m_i)}
  \end{equation}

  Функционал \eqref{random:4}, как и \eqref{random:3}, отвечает за наши априорные знания о окружении и имеет простую интерпретацию. Естественно считать что, если большинство соседей заняты, то и рассматриваемая клетка, скорее всего, непроходима. Аналогичную гипотезу можно сформулировать и для незанятых клеток. Поэтому, считая $w_b < 0$, за каждого соседа, который не согласуются с проходимостью, мы штрафуем. Абсолютная величина коэффициента $w_b$ позволяет регулировать относительный вклад в функционал \eqref{random:1}.

\end{enumerate}

Таким образом задача картирования сводится к задаче максимизации \eqref{random:1} по всем возможным картам проходимости

\begin{equation}\label{random:5}
  m^*(S) = \argmaxl_{m} \Biggl(\phi_{sonars}(m,S) + \phi_{occupancy}(m) + \phi_{borders}(m) \Biggr)
\end{equation} 

\section{Алгоритм картирования стохастическим градиента}

Оптимизационная задача \eqref{random:5} решается методом стохастического градиента. Каждый оптимизационный шаг состоит из следующих действий:

\begin{enumerate}
  \item Случайным образом выбирается клетка $m_i$ и значение проходимости $o(m_i)$ инвертируется
  $$o^*(m_i) = 1 - o(m_i)$$

  \item Для нового значения проходимости клетки $m_i$ пересчитываются  $\phi_{sonars}(m,S)$, $\phi_{occupancy}(m)$ и $\phi_{borders}(m)$.

  В слагаемом $\phi_{sonars}(m,S) = \prod_{s \in S}{p(z_s|m)}$ меняются только те члены произведения, для которых инвертированная клетка лежит в области видимости сенсора. Поэтому можно достаточно быстро пересчитать новое значение 
  $\phi^*_{sonars}(m,S)$.
  
  В силу того, что слагаемые $\phi_{occupancy}(m)$ и $\phi_{borders}(m)$ являются суммами слагаемых, величина которых зависит только значения проходимости самой клетки и её ближайших соседей, поэтому ясно, что при инвертировании одной клетки можно быстро и понятным способом пересчитать новые значения $\phi^*_{occupancy}(m)$ и $\phi^*_{borders}(m)$.

  \item Если $\Phi_{new}(m,S) = \phi^*_{sonars}(m,S) + \phi^*_{occupancy}(m) + \phi^*_{borders}(m)$ > $\Phi(m,S)$, то сохраняем новое значение $o^*(m_i)$ сохраняя новое состояние, иначе возвращаемся в предыдущее состояние. 

  Для того чтобы избежать застревания в локальных минимумах, добавляется рандомизация сохранения нового состояния: инвертирование сохраняется с вероятностью $p_{rand}$, вне зависимости от величины $\Phi_{new}(m,S)$.

\end{enumerate}

\begin{algorithm}[H]
  \caption{Оффлайн версия картирования методом стохастического градиента}
  \label{alg:random_mapping}
  \SetAlgoLined
  \KwData{$m^0$- начальное состояние карты, $S$ - множество наблюдений сонаров, $k$ - число оптимизационных шагов}
  \KwResult{$m$ - карта проходимости}
  \emph{инициализация}\;
  \Begin{
  $m = m^0$\;
  $\phi_{sonars}(m,S), \phi_{occupancy}(m), \phi_{borders}(m)$\;
  $\Phi(m,S) = \phi_{sonars}(m,S) + \phi_{occupancy}(m) + \phi_{borders}(m)$\;
  }
  
  \For{$i = 0; i < k; i = i + 1$}
  {
    случайным образом выбирается клетка карты $m_i$\;
    $o^*(m_i) = 1 - o(m_i)$\;
    пересчитать $\phi^*_{sonars}(m,S), \phi^*_{occupancy}(m), \phi^*_{borders}(m)$\;
    $\Phi^*_(m,S) = \phi^*_{sonars}(m,S) + \phi^*_{occupancy}(m) + \phi^*_{borders}(m)$ > $\Phi(m,S)$\;
    \If{$\Phi^*_(m,S) > \Phi_(m,S)$ или $rand(0,1) < p_{random factor}$}{
      $m = m^*$
      $\phi_{sonars}(m,S) = \phi^*_{sonars}(m,S)$\;
      $\phi_{occupancy}(m) = \phi^*_{occupancy}(m)$\;
      $\phi_{borders}(m) = \phi^*_{borders}(m)$\;
      $\Phi(m,S) = \Phi^*(m,S)$\;
    }
  }

\end{algorithm}

В этой работе имплементирована оффлайн версия алгоритма \ref{alg:random_mapping}, которая на вход получает сразу все наблюдения сонаров, и затем оптимизирует карту проходимости. 

\section{Работа в режиме реального времени}
\label{section:real_time_tech}

Как уже говорилась ранее можно реализовать алгоритм, который работает в режиме реального времени. Далее предлагаются способы того, каким образом это можно сделать.

В режиме реального времени оптимизация ведется одновременно с получением новых данных. Ясно, что если при долгом и непрерывном сборе данных, в определенный момент времени количество наблюдений превысит тот их объем, который возможно обрабатывать в режиме реального времени. Поэтому необходимо выбирать лишь ту часть данных, которые будут алгоритмом в процессе оптимизации. Здесь предлагаются следующие способы выбора наблюдений для использования в оптимизации:

\begin{itemize}
  \item Использовать скользящее окно и рассматривать последние $N_{max}$ измерений - таким образом мы гарантируем, что каждый пересчет $\phi_{sonars}(m,S)$ не превысит $T_{max} = \Delta_t N_{max}$, где $\Delta_t$ - время пересчета одного сонара.

  \item Для каждой клетки хранить номера измерений сонаров, которые содержат её в поле зрения. Ограничение числа привязанных к каждой ячейке измерений значением $N_{max}$ гарантирует, что для каждой ячейки пересчет $\phi_{sonars}(m,S)$ будет занимать времени не более $T_{max} = \Delta_t N_{max}$. Предлагается выбирать $N_{max}$ последних наблюдений. 

  \item Будем использовать трехмерную сетку пространства $(x, y, \phi)$, каждый узел этой сетки хранит список наблюдений, которые принадлежат области пространства $(\Delta x, \Delta y, \Delta \phi)$, соответствующей этому узлу. Тогда в каждом узле можно хранить $N_{max}$ последних измерений или даже эти измерения некоторым образом фильтровать. При этом масштаб этой сетки, может не совпадать с масштабом карты проходимости.
\end{itemize}



