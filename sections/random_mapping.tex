\chapter{Картирование методом стохастического градиента}
\label{random_mapping}

Используя прямую модель, описанную в \ref{thrun_model}, мы предлагаем метод картирования, который использует преимущества прямой модели, и при этом допускает real-time реализацию. Как и раньше, через $m$ будем обозначать карту проходимости. Через $Z = \{z_1, ...,z_T\}$ - множество наблюдений сонаров $z_t$. Через $o(m_i)$ будем обозначать занятость клетки $m_i$: $o(m_i) = 0$ - клетка проходима, $o(m_i) = 1$ - клетка непроходима.

Вначале введем функцию правдоподобия, состоящую из прямой модели сенсора и априорных представлений об окружении. Затем случайным перебором будем максимизировать значение этой функции.

\section{Функция правдоподобия карты проходимости}

Введем следующий функцию от $m$ при заданных наблюдениях $Z$:

\begin{equation}\label{random:1}
  \Phi(m,Z) = \phi_{sonars}(m,Z) + \phi_{occupancy}(m) + \phi_{borders}(m),
\end{equation}

Рассмотрим составляющие части функции \eqref{random:1}

\begin{enumerate}
  \item $\phi_{sonars}$ - распределение наблюдений сонаров $z_t$ при заданной карте проходимости $m$.
  \begin{equation}\label{random:2}
    \phi_{sonars}(m,Z) = p(z_1,...,z_T|m) = \prod_{t}{p(z_t|m)}
  \end{equation}

  Эта часть \eqref{random:1} показывает на сколько хорошо карта $m$ объясняет показания сонаров $z_t$. В работе в качестве модели сонара $p(z_t|m)$ используется прямая модель, описанная в \ref{thrun_model}. Вместо \eqref{random:2} в окончательной формуле используется логарифм от этой функции:

  \begin{equation}\label{random:2.1}
    \phi_{sonars}(m,Z) = \log p(z_1,...,z_T|m) = \sum_{t}{\log p(z_t|m)}
  \end{equation}

  \item $\phi_{occupancy}(m)$ отвечает за априорные знания о проходимости карты

  \begin{equation}\label{random:3}
    \phi_{occupancy}(m) = \sum_{m_i}{w_{o}o(m_i)}
  \end{equation}

  В зависимости от значения весового коэффициента $w_o$ можно регулировать наше первоначальное представление о карте, без учета наблюдений сонаров. Например, при $w_o < 0$ и $\phi_{sonars}(m,Z) = const$ пустая карта будет максимизировать $\Phi(m,Z)$.

  \item $\phi_{borders}(m)$ представляет собой следующую сумму

  \begin{equation}\label{random:4}
    \phi_{borders}(m) = \sum_{m_i}{w_{b}n^2(m_i)}
  \end{equation}

  где $n(m_i)$ - число таких соседей клетки $m_i$, состояние которых не совпадает с состоянием $m_i$. Функция \eqref{random:4}, как и \eqref{random:3}, отвечает за наши априорные знания об окружении и имеет простую интерпретацию. Естественно считать что, если большинство соседей заняты, то и рассматриваемая клетка скорее всего занята. Аналогичную гипотезу можно сформулировать и для незанятых клеток. Поэтому если $w_b < 0$, то клетка будет штрафоваться за каждого соседа, состояние которого не совпадает со состоянием клетки. Абсолютная величина коэффициента $w_b$ позволяет регулировать его относительный вклад в \eqref{random:1}.

\end{enumerate}

Таким образом задача картирования сводится к задаче максимизации \eqref{random:1} по всем возможным картам проходимости

\begin{equation}\label{random:5}
  m^*(Z) = \argmaxl_{m} \Biggl(\phi_{sonars}(m,Z) + \phi_{occupancy}(m) + \phi_{borders}(m) \Biggr)
\end{equation}

\section{Алгоритм картирования стохастическим градиента}

Оптимизационная задача \eqref{random:5} решается методом стохастического градиента. Каждый оптимизационный шаг состоит из следующих действий:

\begin{enumerate}
  \item Случайным образом выбирается клетка $m_i$ и значение проходимости $o(m_i)$ инвертируется
  $$o^*(m_i) = 1 - o(m_i)$$

  \item Для нового состояния клетки $m_i$ пересчитываются  $\phi_{sonars}(m,Z)$, $\phi_{occupancy}(m)$ и $\phi_{borders}(m)$. В $\phi_{sonars}(m,Z) = \sum_{z_t}{\log p(z_t|m)}$ меняются только части суммы, для которых клетка $m_i$ лежит в области видимости сонара. Поэтому можно достаточно быстро пересчитать новое значение $\phi^*_{sonars}(m,Z)$. Также ясно, что при инвертировании одной клетки $m_i$ возможно быстро получить новые значения $\phi^*_{occupancy}(m)$ и $\phi^*_{borders}(m)$, так как $\phi_{occupancy}(m)$ и $\phi_{borders}(m)$ являются суммами функций от каждой клетки карты $m_k$, и их значения зависят только состояния клетки $m_k$ и её соседей.

  \item Если $\Phi^*(m,Z) = \phi^*_{sonars}(m,Z) + \phi^*_{occupancy}(m) + \phi^*_{borders}(m)$ > $\Phi(m,Z)$, то сохраняем новое значение $o^*(m_i)$ и новые значения: $\Phi^*(m,Z)$, $\phi^*_{sonars}(m,Z)$, $\phi^*_{occupancy}(m)$, $\phi^*_{borders}(m)$; иначе возвращаемся в предыдущее состояние. Для того чтобы избежать застревания в локальных минимумах, добавляется рандомизация сохранения нового состояния: инвертирование сохраняется с вероятностью $p_{random\_factor}$, вне зависимости от величины $\Phi^*(m,Z)$.

\end{enumerate}

В этой работе имплементирована оффлайн версия алгоритма \ref{alg:random_mapping}, которая на вход получает сразу все наблюдения сонаров, и затем оптимизирует карту проходимости.
\\
\\
\begin{algorithm}[H]
  \caption{Оффлайн версия картирования методом стохастического градиента}
  \label{alg:random_mapping}
  \SetAlgoLined
  \KwData{$m^0$- начальное состояние карты, $Z$ - множество наблюдений сонаров, $k$ - число оптимизационных шагов}
  \KwResult{$m$ - карта проходимости}
  \emph{инициализация}\;
  \Begin{
  $m = m^0$\;
  $\phi_{sonars}(m,Z), \phi_{occupancy}(m), \phi_{borders}(m)$\;
  $\Phi(m,Z) = \phi_{sonars}(m,Z) + \phi_{occupancy}(m) + \phi_{borders}(m)$\;
  }

  \For{$i = 0; i < k; i = i + 1$}
  {
    случайным образом выбирается клетка карты $m_i$\;
    $o^*(m_i) = 1 - o(m_i)$\;
    пересчитать $\phi^*_{sonars}(m,Z), \phi^*_{occupancy}(m), \phi^*_{borders}(m)$\;
    $\Phi^*_(m,Z) = \phi^*_{sonars}(m,Z) + \phi^*_{occupancy}(m) + \phi^*_{borders}(m)$ > $\Phi(m,Z)$\;
    \If{$\Phi^*_(m,Z) > \Phi_(m,Z)$ или $rand(0,1) < p_{random factor}$}{
      $m = m^*$
      $\phi_{sonars}(m,Z) = \phi^*_{sonars}(m,Z)$\;
      $\phi_{occupancy}(m) = \phi^*_{occupancy}(m)$\;
      $\phi_{borders}(m) = \phi^*_{borders}(m)$\;
      $\Phi(m,Z) = \Phi^*(m,Z)$\;
    }
  }

\end{algorithm}

\section{Работа в режиме реального времени}
\label{section:real_time_tech}

На основе предложенного метода можно реализовать алгоритм, который работает в режиме реального времени. В этом режиме оптимизация ведется одновременно с получением новых данных. Ясно, что при долгом и непрерывном сборе данных, в определенный момент времени количество наблюдений превысит тот их объем, который возможно обрабатывать на лету. Поэтому для обработки необходимо выбирать лишь некоторую часть данных, чтобы не выйти за рамки отведенного оптимизации времени. Здесь предлагаются следующие способы составления выборки наблюдений для оптимизации:

\begin{itemize}
  \item Использовать скользящее окно и рассматривать последние $N_{max}$ наблюдений - таким образом мы гарантируем, что каждый пересчет $\phi_{sonars}(m,Z)$ не превысит $T_{max} = \Delta_t N_{max}$, где $\Delta_t$ - время пересчета одного слагаемого из $\phi_{sonars}(m,Z)$ соответствующего наблюдения.

  \item Для каждой клетки хранить номера $t$ наблюдений $z_t$ сонаров, которые содержат её в поле зрения. Ограничение числа наблюдений привязанных к каждой ячейке значением $N_{max}$ гарантирует, что для каждой ячейки пересчет $\phi_{sonars}(m,Z)$ будет занимать времени не более $T_{max} = \Delta_t N_{max}$. Предлагается выбирать $N_{max}$ последних наблюдений.

  \item В каждом узле трехмерной сетки $(x_i, y_i, \varphi_i)$ хранится список наблюдений $z_t = (x_t, y_t, \varphi_t, m_t)$, которые принадлежат соответствующей части пространства: $x_t \in [x_i - \Delta_x, x_i + \Delta_x]$,  $y_t \in [y_i - \Delta_y, y_i + \Delta_y]$ и $\varphi_t \in [\varphi_i - \Delta_{\varphi_i}, \varphi_i + \Delta_{\varphi_i}]$. Тогда в каждом узле можно хранить $N_{max}$ последних измерений или некоторым образом фильтрованные наблюдения. При этом масштаб этой сетки, может не совпадать с масштабом карты проходимости.
\end{itemize}



